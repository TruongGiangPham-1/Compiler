// circular queue type
// typedef integer[*] IntegerSet;

procedure print_graph(integer[*, *] GRAPH, integer n) {
    // prints out the adjacency matrix
    loop i in 1..n {
        GRAPH[i, 1] -> std_output;
        loop j in 2..n {
            " " -> std_output;
            GRAPH[i, j] -> std_output;
        }
        "\n" -> std_output;
    }
}

// start all of the nodes as unvisited
function initVisited(integer n) returns integer[*] = [ i in 1..n | 0 ];

// true if we have visited all nodes (i.e. all nodes are 1)
// TODO: some bugs in typecheck integer stuff
function doneVisiting(integer[*] visited) returns boolean {
    // filtered = ([ i is 0 ], [ i is 1 ]);
    var filtered = [ i in visited & i == 0 ];
    integer[*] filteredVisited = filtered.1;
    return length(filteredVisited) == 0; // true if there no unvisited nodes
}

procedure popMinNode(var integer[*] visited, const real[*] dist, integer n) returns integer {
    // find the minimum node that we haven't visited yet
    // after doing so, mark it as visited

    integer minNode = -1;
    real minDist = 1e100; // simulate infinity

    loop i in 1..n {
        if (visited[i] == 0) { // out of all the unvisited nodes...
            if (dist[i] < minDist) { // if the distance is less than the current minimum...
                minNode = i;
                minDist = dist[i];
            }
        }
    }
    visited[minNode] = 1; // mark the node as visited

    return minNode;
}

procedure main() returns integer {
    integer n; // number of nodes in the graph
    n <- std_input;

    integer s; // source node
    integer t; // target node
    s <- std_input;
    t <- std_input;

    // when format works, remove this
    "Going from " -> std_output;
    s -> std_output;
    " to " -> std_output;
    t -> std_output;
    " in a graph with " -> std_output;
    n -> std_output;
    " nodes.\n" -> std_output;

    // read the graph
    integer[n, n] GRAPH;
    loop i in 1..n, j in 1..n {
        GRAPH[i, j] <- std_input;
    }
    call print_graph(GRAPH, n);

    // ==============
    // START DIJKSTRA
    // ==============
    real[n] dist = 1e100; // simulate infinity
    dist[s] = 0; // distance from source to source is 0

    integer[n] prev = -1;
    integer[*] visited = initVisited(n);

    loop while (not doneVisiting(visited)) {
        integer minNode = popMinNode(visited, dist, n);
        "Current minNode is " -> std_output;
        minNode -> std_output;
        " with distance " -> std_output;
        dist[minNode] -> std_output;
        "\n" -> std_output;

        if (minNode == t) {
            "Found target node " -> std_output;
            t -> std_output;
            " with distance " -> std_output;
            dist[t] -> std_output;
            "\n" -> std_output;
            break;
        }

        // loop through all neighbours of minNode that are in Q
        var validNeighboursFilter = [ i in 1..n & GRAPH[minNode, i] > 0 and visited[i] == 0 ];
        // integer[*] validNeighbours = validNeighboursFilter.1;
        // "  Valid Neighbours: " -> std_output;
        // validNeighbours -> std_output;
        // "\n" -> std_output;

        loop i in validNeighboursFilter.1 {
            real alt = dist[minNode] + GRAPH[minNode, i];
            if (alt < dist[i]) {
                dist[i] = alt;
                prev[i] = minNode;
            }
        }
    }

    // ============
    // Print answer
    // ============
    "Shortest path from " -> std_output;
    s -> std_output;
    " to " -> std_output;
    t -> std_output;
    " is " -> std_output;
    dist[t] -> std_output;
    "\n" -> std_output;

    return 0;
}
